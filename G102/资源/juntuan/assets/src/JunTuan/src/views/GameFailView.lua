---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by hkc.
--- DateTime: 2021/5/13 14:11
---

-- 询问复活界面
local GameFailView = class("GameFailView", ViewBase)
local gemCost = UserData.Shared():getGemCost(Define.ENUM_GEM_COST.GAME_REVIVE)
function GameFailView:ctor(para)
    self:enableNodeEvents()
    self:initData(para)
end

function GameFailView:onEnter()
    self:initView()
    self:addNotify()
    --self:startTimeCountDown()
end

function GameFailView:initData(para)
    self.parent = para.parent
    self.curTime = 10
end

function GameFailView:initView()
    local para = {
        csb = JunTuanCfg.csbCfg.GameView.game_fail,
        setSize = true
    }
    local ui = ViewBase:createCSB(para)
    self:addChild(ui)

    local panel_black = ui:getChildByName("Panel_black")
    local panel_main = panel_black:getChildByName("Panel_main")
    local btn_revive = panel_main:getChildByName("btn_revive")
    local btn_give_up = panel_main:getChildByName("btn_give_up")
    self.btn_revive = btn_revive
    self.txt_time = btn_revive:getChildByName("Text_num"):hide()
    self.txt_time:setString(self.curTime)
    self:refreshBtn()
    local function btnCall(btn)
        if btn == btn_revive then
            -- 发送复活请求
            self:sendContinue()
        elseif btn == btn_give_up then
            -- 放弃复活
            self:giveUp()
        end
    end
    ExternalTools:addBtnTouchEventListener(btn_revive, btnCall)
    ExternalTools:addBtnTouchEventListener(btn_give_up, btnCall)
end

function GameFailView:refreshBtn()
    local btn_revive = self.btn_revive
    local icon_video = btn_revive:getChildByName("icon_video")
    local txt_revive = btn_revive:getChildByName("Text_revive")
    if UserData.Shared():isMonthCardUser() then
        icon_video:hide()
        txt_revive:setString("免费复活")
    else
        local gem = gemCost
        icon_video:getChildByName("Text_num"):setString("x" .. gem)
        icon_video:show()
        txt_revive:setString("立即复活")
    end
end

-- 放弃复活
function GameFailView:giveUp()
    MsgSendMgr:sendGameOver()
    self:removeFromParent(true)
end

-- 开始复活倒计时
function GameFailView:startTimeCountDown()
    local function update(dt)
        self.curTime = self.curTime - dt
        self.txt_time:setString(self.curTime)
        if self.curTime <= 0 then
            self:stopTimeCountDown()
            self:giveUp()
        end
    end
    self.txt_time:show()
    if not self.mainScheduler then
        local scheduler = cc.Director:getInstance():getScheduler()
        self.mainScheduler = scheduler:scheduleScriptFunc(update, 1, false)
    end
end

-- 关闭复活倒计时
function GameFailView:stopTimeCountDown()
    if self.mainScheduler then
        local scheduler = cc.Director:getInstance():getScheduler()
        scheduler:unscheduleScriptEntry(self.mainScheduler)
        self.mainScheduler = nil
    end
end

-- 发送复活请求
function GameFailView:sendContinue()
    if UserData.Shared():get_lDiamond() >= gemCost then
        MsgSendMgr:sendGameRevive()
    else
        GameTool:showBuyGemView(self)
    end
end

-- 处理复活请求
function GameFailView:handleContinue(data)
    local ret = data.result
    local blood = data.blood
    blood = GameTool:dataEncrypt(blood)
    if ret.noError then
        local gem = gemCost
        GameTool:updateGem(-gem)
        self.parent:continueGame(blood)
        self:removeFromParent(true)
    else
        GameTool:showTxtTip(ret.outMsg)
    end
end

function GameFailView:addNotify()
    self.onGameRevive = MessageManager.Shared():addMsg(MsgKeyData.onGameRevive, function (data)
        self:handleContinue(data)
    end)
end

function GameFailView:removeNotify()
    MessageManager.Shared():removeMsg(MsgKeyData.onGameRevive, self.onGameRevive)
end

function GameFailView:onExit()
    self:removeNotify()
    self:stopTimeCountDown()
end

return GameFailView